name: Hackathon
services:
  postgres:
    image: postgres:16
    container_name: postgres_hackathon
    restart: unless-stopped
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - "5432:5432"
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5

  authservice:
    build:
      context: . # Контекст сборки - корень проекта
      dockerfile: AuthService/Dockerfile # Путь к Dockerfile вашего сервиса
    env_file:
      - .env 
    container_name: AuthService
    ports:
      - "8012:80"   # Хост 8012 -> Контейнер 80 (HTTP)
      - "8011:443"  # Хост 8011 -> Контейнер 443 (HTTPS)
    environment:
      - ASPNETCORE_ENVIRONMENT=Development # Или Development, как вам нужно
      - POSTGRES_HOST=postgres
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - ROLES=${ROLES}
      - JwtSettings__SecretKey=${JwtSettings__SecretKey}
      - JwtSettings__Issuer=${JwtSettings__Issuer}
      - JwtSettings__Audience=${JwtSettings__Audience}
      - JwtSettings__DurationInHours=${JwtSettings__DurationInHours}
      - AUTHENTICATION__GOOGLE__CLIENTID=${AUTHENTICATION__GOOGLE__CLIENTID}
      - AUTHENTICATION__GOOGLE__CLIENTSECRET=${AUTHENTICATION__GOOGLE__CLIENTSECRET}
      # Настройки для HTTPS
      - ASPNETCORE_URLS=http://+:80;https://+:443
      - KESTREL_CERTIFICATE_PASSWORD=${KESTREL_CERT_PASSWORD}
      # CORS настройки
      - AllowedOrigins__0=http://localhost:3010
      - AllowedOrigins__1=http://localhost:3000
      - AllowedOrigins__2=http://localhost:8000
      - AllowedOrigins__3=http://localhost:8001
      - AllowedOrigins__4=http://authservicefrontend
      - AllowedOrigins__5=http://frontend
      - AllowedOrigins__6=http://gateway
    volumes:
      - ./cert.pfx:/app/cert.pfx
    depends_on:
      - postgres
  gateway:
    build:
      context: . # Контекст сборки - корень проекта
      dockerfile: HackathonGateway/HackathonGateway/Dockerfile # Путь к Dockerfile вашего сервиса
    env_file:
      - .env
    container_name: Gateway
    ports:
      - "8000:80"   # Хост 8080 -> Контейнер 80 (HTTP)
      - "8001:443"  # Хост 8443 -> Контейнер 443 (HTTPS)
    environment:
      - ASPNETCORE_ENVIRONMENT=Development 
      - JwtSettings__SecretKey=${JwtSettings__SecretKey}
      - JwtSettings__Issuer=${JwtSettings__Issuer}
      - JwtSettings__Audience=${JwtSettings__Audience}
      - JwtSettings__DurationInHours=${JwtSettings__DurationInHours}
      # Настройки для HTTPS
      - ASPNETCORE_URLS=http://+:80;https://+:443
      - KESTREL_CERTIFICATE_PASSWORD=${KESTREL_CERT_PASSWORD}
      # CORS настройки
      - AllowedOrigins__0=http://localhost:3010
      - AllowedOrigins__1=http://localhost:3000
      - AllowedOrigins__2=http://authservicefrontend
      - AllowedOrigins__3=http://frontend
    volumes:
      - ./cert.pfx:/app/cert.pfx
    depends_on:
      - authservice
  soundservice:
    build:
      context: .
      dockerfile: SoundService/SoundService/Dockerfile
    env_file:
      - .env
    container_name: SoundService
    ports: 
      - "8020:80"
      #- "8021:443"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development 
      # Настройки для HTTPS
      - ASPNETCORE_URLS=http://+:80; #https://+:443
      - POSTGRES_HOST=postgres
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - ROLES=${ROLES}
      - MINIO_ENDPOINT=${MINIO_ENDPOINT}
      - MINIO_PORT=${MINIO_PORT}
      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
      - MINIO_BUCKET_NAME=${MINIO_BUCKET_NAME}
      - ELASTIC_URI=${ELASTIC_URI}


       # --- НОВЫЕ ПЕРЕМЕННЫЕ ДЛЯ RABBITMQ ---
      - RABBITMQ_HOSTNAME=rabbitmq # Имя сервиса RabbitMQ
      - RABBITMQ_PORT=5672
      - RABBITMQ_USERNAME=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASS}
      - AUDIO_PROCESSING_QUEUE_NAME=audio_processing_tasks # Имя очереди для задач
      - RESULTS_QUEUE_NAME=audio_results
    depends_on:
      - postgres
      - rabbitmq 
      - minio    
      - elasticsearch
  frontend:
    build:
      context: . # Контекст сборки - корень проекта
      dockerfile: FrontendService/Dockerfile
    container_name: Frontend
    ports:
      - "3000:80"   # Хост 3000 -> Контейнер 80 (HTTP)
    depends_on:
      - gateway
      - postgres
      - elasticsearch
      - minio

  authservicefrontend:
    build:
      context: . # Контекст сборки - корень проекта
      dockerfile: AuthServiceFrontend/Dockerfile
    container_name: AuthServiceFrontend
    restart: always
    ports:
      - "3010:80"   # Хост 3010 -> Контейнер 80 (HTTP)
    environment:
      - ASPNETCORE_URLS=http://+:80;https://+:443 # Kestrel будет слушать оба порта
      - KESTREL_CERTIFICATE_PASSWORD=${KESTREL_CERT_PASSWORD} # Ссылка на переменную из .env
    depends_on:
      - authservice
      - gateway
  elasticsearch:
    image: elasticsearch:8.17.3
    container_name: elastic
    restart: unless-stopped
    environment:
      - node.name=elasticsearch
      - cluster.name=es-docker-cluster
      - discovery.type=single-node
      - xpack.security.enrollment.enabled=false
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
      - "9300:9300"
    volumes:
      - ./data/elasticsearch:/usr/share/elasticsearch/data
      - ./logs/elasticsearch:/usr/share/elasticsearch/logs

  kibana:
    image: kibana:8.17.3
    container_name: kibana_hackaton
    restart: unless-stopped
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch
    environment:
      - node.name=kibana
      - cluster=es-docker-cluster
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    
  minio:
    image: minio/minio
    container_name: minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=${MINIO_ROOT_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}
    command: server /data --console-address :9001

  mc-init:
    image: minio/mc
    container_name: mc-init
    depends_on:
      - minio
    environment:
      # Передаем ВСЕ необходимые переменные из .env
      - MINIO_ROOT_USER=${MINIO_ROOT_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}
      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
      - MINIO_BUCKET_NAME=${MINIO_BUCKET_NAME}
    volumes:
      # Эта строка отвечает за то, чтобы содержимое вашей папки
      # ./music_test/original_tracks на хосте было доступно
      # внутри контейнера mc-init по пути /init-audio
      - ./music_test/:/init-audio
      - ./init-mc.sh:/usr/local/bin/init-mc.sh # Монтируем скрипт
    entrypoint: ["/usr/local/bin/init-mc.sh"]   # <--- ИЗМЕНЕНИЕ ЗДЕСЬ

  demucs_service: # Этот сервис теперь в основном для сборки образа
    build:
      context: ./demucs
      dockerfile: Dockerfile
    image: local/demucs_app # Присваиваем имя собираемому образу
    container_name: demucs_build_helper # Имя контейнера не так важно, т.к. он не будет постоянно работать
    volumes:
      # Эти тома здесь для того, чтобы docker-compose их "знал",
      # но фактическое использование будет при docker run из FlaskServise.
      # Монтирование в этом сервисе не имеет смысла, так как он не будет запущен.
      # Однако, demucs_models_cache может быть полезен, если demucs/Dockerfile
      # скачивает модели при сборке и кладет их в /data/models.
      - demucs_models_cache:/data/models


  flask_service:
    build:
      context: .
      dockerfile: FlaskServise/Dockerfile
    container_name: flask_service
    restart: unless-stopped
    ports:
      - "5001:5000" # Хост:Контейнер
    volumes:
      # Используем bind mount для отладки видимости файлов
      - ./shared_docker_data:/shared_host_mount 
      - /var/run/docker.sock:/var/run/docker.sock # Монтирование Docker-сокета
      # - shared_audio_data:/app/shared_audio_data # Временно заменяем именованный том
    depends_on:
      - demucs_service # FlaskServise зависит от demucs_service
    environment:
      # Убедитесь, что DEMUCS_CONTAINER_NAME в app.py соответствует имени контейнера demucs_service
      - DEMUCS_CONTAINER_NAME=demucs_service 
      # SHARED_DIR_FLASK и SHARED_DIR_DEMUCS_CMD_ARG уже определены в app.py как /shared_audio_data
      # Эти переменные окружения можно также установить здесь, если хотите переопределить значения из app.py
      # --- НОВЫЕ ПЕРЕМЕННЫЕ ДЛЯ RABBITMQ ---
      - RABBITMQ_HOSTNAME=rabbitmq
      - RABBITMQ_PORT=5672
      - RABBITMQ_USERNAME=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASS}
      - RESULTS_QUEUE_NAME=audio_results
      - AUDIO_PROCESSING_QUEUE_NAME=audio_processing_tasks # Та же очередь
  rabbitmq: # Имя сервиса, по которому другие контейнеры будут к нему обращаться
    image: rabbitmq:3-management-alpine # Образ с UI для управления
    container_name: rabbitmq_broker # Имя самого контейнера
    ports:
      - "5672:5672"  # Порт для AMQP (протокол RabbitMQ)
      - "15672:15672" # Порт для веб-интерфейса (логин/пароль по умолчанию guest/guest)
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq/ # Для сохранения данных RabbitMQ (очередей, сообщений)
    environment:
      # Для хакатона можно оставить guest/guest, но для продакшена лучше задать свои
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER} # Использует из .env или guest по умолчанию
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASS} # Использует из .env или guest по умолчанию
    restart: unless-stopped
    healthcheck: # Опционально, но полезно
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 30s
      timeout: 10s
      retries: 5

volumes:
  # shared_audio_data: {} # Временно не используется
  demucs_models_cache: {} # Том для кэширования моделей Demucs
  rabbitmq_data: {}
